<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>2D Aim Trainer — FN-style Shooting</title>
<style>
  :root{
    --bg:#0e1320; --panel:#0b1220; --accent:#22d3ee; --muted:#9fb0c6; --ok:#10b981; --warn:#f59e0b; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg),#070d1a);color:#e8f1fb;font-family:system-ui,-apple-system,Segoe UI,Meiryo,Arial;overflow:hidden}
  #hud{position:absolute;top:10px;left:10px;background:rgba(0,0,0,.35);backdrop-filter:blur(4px);padding:10px 12px;border-radius:10px;display:flex;gap:14px;align-items:center}
  .stat{font-size:14px;color:var(--muted)}
  .stat b{color:#fff}
  #controls{position:absolute;top:10px;right:10px;background:rgba(0,0,0,.35);backdrop-filter:blur(4px);padding:10px;border-radius:10px;display:flex;gap:8px;align-items:center}
  input[type=text]{width:80px;padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,.08);background:rgba(255,255,255,.06);color:#fff}
  button{background:var(--accent);color:#01202a;border:none;border-radius:10px;padding:8px 10px;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,.08)}
  #mobileBar{position:absolute;bottom:12px;left:0;right:0;display:flex;justify-content:center;gap:10px}
  .mBtn{min-width:90px;padding:12px 14px;border-radius:14px;border:1px solid rgba(255,255,255,.08);background:rgba(255,255,255,.06);color:#e8f1fb;font-weight:800}
  #game{display:block;width:100vw;height:100vh}
  .badge{padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.08);font-size:12px}
</style>
</head>
<body>
  <div id="hud">
    <div class="stat">Score: <b id="score">0</b></div>
    <div class="stat">Hit%: <b id="acc">0%</b></div>
    <div class="stat">DMG: <b id="dmg">0</b></div>
    <div class="stat">Mag: <b id="mag">30/30</b></div>
    <div class="stat badge" id="adsState">ADS: OFF</div>
    <div class="stat badge" id="assistState">Assist: OFF</div>
  </div>

  <div id="controls">
    <span class="stat">コード:</span>
    <input type="text" id="codeInput" placeholder="7777" />
    <button id="codeBtn" class="ghost">OK</button>
    <button id="reloadBtn" class="ghost">リロード(R)</button>
    <button id="adsBtn" class="ghost">ADS切替(右クリック)</button>
    <button id="resetBtn" class="ghost">リセット</button>
  </div>

  <div id="mobileBar">
    <button id="mFire" class="mBtn">発射</button>
    <button id="mReload" class="mBtn">リロード</button>
    <button id="mADS" class="mBtn">ADS</button>
  </div>

  <canvas id="game"></canvas>

<script>
(() => {
  // ========== Canvas ==========
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function resize(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // ========== UI Elements ==========
  const scoreEl = document.getElementById('score');
  const accEl = document.getElementById('acc');
  const dmgEl = document.getElementById('dmg');
  const magEl = document.getElementById('mag');
  const adsStateEl = document.getElementById('adsState');
  const assistStateEl = document.getElementById('assistState');
  const codeInput = document.getElementById('codeInput');
  const codeBtn = document.getElementById('codeBtn');
  const reloadBtn = document.getElementById('reloadBtn');
  const adsBtn = document.getElementById('adsBtn');
  const resetBtn = document.getElementById('resetBtn');
  const mFire = document.getElementById('mFire');
  const mReload = document.getElementById('mReload');
  const mADS = document.getElementById('mADS');

  // ========== Game State ==========
  const RNG = () => Math.random();
  let score = 0, shots = 0, hits = 0, totalDamage = 0;
  let aimAssist = false;
  let ads = false; // aim down sight (reduce bloom)
  let firing = false;
  let canShoot = true;
  let reloading = false;

  // Gun params (FNっぽいアサルト)
  const FIRE_RATE = 10;         // rounds/sec
  const RELOAD_TIME = 1.9 * 1000; // ms
  const MAG_SIZE = 30;
  const DAMAGE_BODY = 34;
  const DAMAGE_HEAD = 68;
  const BASE_BLOOM = 6;   // px角度相当（ADSで縮小）
  const ADS_BLOOM = 2;
  const RECOIL_PER_SHOT = 1.2; // ブレ上乗せ
  const RECOIL_DECAY = 4;      // /sec
  const TRACER_TIME = 120;     // ms

  let ammo = MAG_SIZE;
  let recoilBloom = 0; // リコイルで広がるブレ
  let lastShotAt = 0;

  // Crosshair center is screen center
  const center = () => ({ x: canvas.width/2, y: canvas.height/2 });

  // Targets (circle with HP)
  // body radius r, inner head r*0.5
  let targets = [];
  function spawnTarget(){
    const pad = 60;
    const r = 36 + Math.floor(RNG()*10); // 36-45
    const x = pad + RNG()*(canvas.width - pad*2);
    const y = pad + RNG()*(canvas.height - pad*2);
    targets.push({ x,y,r, hp: 100, movePhase: RNG()*Math.PI*2, moveSpeed: 0.9+RNG()*0.8, dir: (RNG()<0.5?-1:1) });
  }
  // keep some targets alive
  function ensureTargets(n=5){
    while(targets.length<n) spawnTarget();
  }

  // Tracers (fade lines)
  let tracers = []; // {x1,y1,x2,y2,t}
  function addTracer(x1,y1,x2,y2){ tracers.push({x1,y1,x2,y2,t:TRACER_TIME}); }

  // ========== Aim Assist ==========
  function getNearestTargetToPoint(px,py){
    if(targets.length===0) return null;
    let best=null, bd=Infinity;
    for(const t of targets){
      const dx = px - t.x, dy = py - t.y;
      const d = Math.hypot(dx,dy);
      if(d<bd){bd=d; best=t;}
    }
    return best;
  }
  function lockOnPoint(){
    // 完全ロックオン: 画面中心から最も近いターゲット中心へ
    const c = center();
    const nearest = getNearestTargetToPoint(c.x,c.y);
    return nearest ? {x: nearest.x, y: nearest.y, target: nearest} : {x: c.x, y: c.y, target:null};
  }

  // ========== Shooting ==========
  function currentBloom(){
    const base = ads ? ADS_BLOOM : BASE_BLOOM;
    return base + recoilBloom;
  }

  function tryShoot(){
    const now = performance.now();
    const delay = 1000 / FIRE_RATE;
    if(!canShoot || reloading) return;
    if(now - lastShotAt < delay) return;

    if(ammo<=0){ reload(); return; }

    lastShotAt = now;
    ammo--; shots++; canShoot = true;

    // Decide aim point
    let aim;
    if(aimAssist){
      aim = lockOnPoint(); // perfect lock
    }else{
      // bloom: add random spread from center
      const c = center();
      const spread = currentBloom();
      const ax = c.x + (RNG()*2-1)*spread;
      const ay = c.y + (RNG()*2-1)*spread;
      aim = {x:ax, y:ay, target:null};
    }

    // Ray from center to aim.x/y (hitscan)
    const c = center();
    // Visual tracer end: extend beyond aim to screen edge direction
    const dir = Math.atan2(aim.y - c.y, aim.x - c.x);
    const endX = c.x + Math.cos(dir) * 2000;
    const endY = c.y + Math.sin(dir) * 2000;
    addTracer(c.x,c.y,endX,endY);

    // Hit test: find first target intersected along ray
    let hitInfo = rayHitTarget(c.x,c.y,dir);
    if(aimAssist && aim.target){
      // Force hit chosen target (center ray to target)
      hitInfo = { target: aim.target, head: false, x: aim.target.x, y: aim.target.y };
    }

    if(hitInfo){
      const t = hitInfo.target;
      const dmg = hitInfo.head ? DAMAGE_HEAD : DAMAGE_BODY;
      t.hp -= dmg;
      totalDamage += dmg;
      if(t.hp<=0){
        // destroy target
        targets = targets.filter(tt => tt!==t);
        score += 1;
        hits += 1;
      }else{
        // partial hit counts as hit for acc
        hits += 1;
      }
    }

    // Recoil increase
    recoilBloom += RECOIL_PER_SHOT;
    // Muzzle flash kick (small visual)
    flashTimer = 60; // ms

    updateUI();
  }

  // Ray-circle intersection (return nearest target)
  function rayHitTarget(x0,y0,theta){
    let best=null, bestDist=Infinity;
    const dx = Math.cos(theta), dy = Math.sin(theta);
    for(const t of targets){
      // Check head then body to mark headshot
      const resHead = rayCircle(x0,y0,dx,dy,t.x,t.y,t.r*0.5);
      const resBody = rayCircle(x0,y0,dx,dy,t.x,t.y,t.r);
      const hit = resHead || resBody;
      if(hit && hit.dist<bestDist){
        bestDist = hit.dist;
        best = { target:t, head: !!resHead, x: hit.x, y: hit.y };
      }
    }
    return best;
  }
  function rayCircle(x0,y0,dx,dy,cx,cy,r){
    // parametric: p = (x0,y0) + t*(dx,dy), t>=0
    const fx = x0 - cx, fy = y0 - cy;
    const a = dx*dx + dy*dy;
    const b = 2*(fx*dx + fy*dy);
    const c = fx*fx + fy*fy - r*r;
    const disc = b*b - 4*a*c;
    if(disc<0) return null;
    const s = Math.sqrt(disc);
    const t1 = (-b - s)/(2*a);
    const t2 = (-b + s)/(2*a);
    let t = null;
    if(t1>=0) t = t1; else if(t2>=0) t = t2;
    if(t===null) return null;
    return { x: x0 + dx*t, y: y0 + dy*t, dist: t };
  }

  // ========== Reload ==========
  function reload(){
    if(reloading || ammo===MAG_SIZE) return;
    reloading = true; canShoot=false;
    setTimeout(()=>{
      ammo = MAG_SIZE;
      reloading = false; canShoot=true;
      updateUI();
    }, RELOAD_TIME);
  }

  // ========== Update / Draw ==========
  let last = performance.now();
  let flashTimer = 0;

  function update(dt){
    // recoil decay
    const dec = RECOIL_DECAY * dt;
    recoilBloom = Math.max(0, recoilBloom - dec);

    // move targets: gentle sine
    for(const t of targets){
      t.movePhase += t.moveSpeed * dt;
      t.x += Math.sin(t.movePhase*0.9) * 0.15 * t.dir * (1+Math.random()*0.1);
      t.y += Math.cos(t.movePhase*0.7) * 0.12 * t.dir;
      // keep in bounds
      const pad=t.r+8;
      if(t.x<pad) t.x=pad; if(t.x>canvas.width-pad) t.x=canvas.width-pad;
      if(t.y<pad) t.y=pad; if(t.y>canvas.height-pad) t.y=canvas.height-pad;
    }

    // tracers fade
    tracers.forEach(tr => tr.t -= dt*1000);
    tracers = tracers.filter(tr => tr.t>0);

    if(flashTimer>0) flashTimer -= dt*1000;

    ensureTargets(5);
  }

  function draw(){
    // background
    ctx.fillStyle = '#08101e';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // tracers
    tracers.forEach(tr=>{
      const alpha = Math.max(0, tr.t/TRACER_TIME);
      ctx.strokeStyle = `rgba(120,200,255,${alpha})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(tr.x1, tr.y1);
      ctx.lineTo(tr.x2, tr.y2);
      ctx.stroke();
    });

    // targets
    targets.forEach(t=>{
      // body
      ctx.beginPath();
      ctx.fillStyle = '#ef4444';
      ctx.arc(t.x,t.y,t.r,0,Math.PI*2); ctx.fill();
      // head
      ctx.beginPath();
      ctx.fillStyle = '#ffffff';
      ctx.arc(t.x,t.y,t.r*0.5,0,Math.PI*2); ctx.fill();
      // hp ring
      const hpRatio = Math.max(0, t.hp)/100;
      ctx.strokeStyle = 'rgba(255,255,255,.7)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(t.x,t.y,t.r+4,-Math.PI/2, -Math.PI/2 + Math.PI*2*hpRatio);
      ctx.stroke();
    });

    // crosshair
    const c = center();
    ctx.strokeStyle = '#22d3ee';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(c.x-8, c.y); ctx.lineTo(c.x+8, c.y);
    ctx.moveTo(c.x, c.y-8); ctx.lineTo(c.x, c.y+8);
    ctx.stroke();

    // gun (bottom center)
    ctx.save();
    const gunY = canvas.height - 60;
    ctx.translate(c.x, gunY);
    // muzzle flash
    if(flashTimer>0){
      ctx.fillStyle = 'rgba(255,220,120,0.8)';
      ctx.fillRect(30,-6,16,12);
    }
    // weapon body
    ctx.fillStyle = '#2b3345';
    ctx.fillRect(-28,-10,56,20);
    ctx.fillStyle = '#1b2233';
    ctx.fillRect(-12,-24,24,14);
    ctx.restore();

    // bloom indicator
    const bloom = currentBloom();
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.beginPath();
    ctx.arc(c.x,c.y, Math.max(10,bloom*4), 0, Math.PI*2);
    ctx.stroke();
  }

  function loop(now){
    const dt = (now - last)/1000; last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ========== UI ==========
  function updateUI(){
    scoreEl.textContent = score;
    const acc = shots===0 ? 0 : (hits/shots*100);
    accEl.textContent = acc.toFixed(1)+'%';
    dmgEl.textContent = totalDamage;
    magEl.textContent = `${ammo}/${MAG_SIZE}` + (reloading?' (RELOADING)':'');
    adsStateEl.textContent = 'ADS: ' + (ads?'ON':'OFF');
    assistStateEl.textContent = 'Assist: ' + (aimAssist?'ON':'OFF');
  }
  updateUI();

  // ========== Input ==========
  // Mouse / Touch fire (hold for auto)
  canvas.addEventListener('mousedown', (e)=>{
    if(e.button===0){ firing = true; tryShoot(); }
  });
  window.addEventListener('mouseup', ()=>{ firing=false; });
  canvas.addEventListener('contextmenu', e=>{ e.preventDefault(); toggleADS(); });

  canvas.addEventListener('touchstart', (e)=>{
    firing = true; tryShoot();
  }, {passive:true});
  window.addEventListener('touchend', ()=>{ firing=false; }, {passive:true});

  // Auto fire timer
  setInterval(()=>{
    if(firing) tryShoot();
  }, Math.floor(1000 / FIRE_RATE));

  // Keyboard
  window.addEventListener('keydown', (e)=>{
    if(e.code==='KeyR') reload();
    if(e.code==='ShiftLeft' || e.code==='ShiftRight') toggleADS();
  });

  function toggleADS(){
    ads = !ads;
    updateUI();
  }

  // Buttons
  reloadBtn.addEventListener('click', reload);
  adsBtn.addEventListener('click', toggleADS);
  resetBtn.addEventListener('click', ()=>{
    score=0; shots=0; hits=0; totalDamage=0; ammo=MAG_SIZE; reloading=false; recoilBloom=0; tracers=[]; targets=[];
    ensureTargets(5);
    updateUI();
  });

  // Mobile
  let mHold=false;
  mFire.addEventListener('touchstart', ()=>{ mHold=true; firing=true; tryShoot(); }, {passive:true});
  mFire.addEventListener('touchend', ()=>{ mHold=false; firing=false; }, {passive:true});
  mReload.addEventListener('touchstart', ()=>reload(), {passive:true});
  mADS.addEventListener('touchstart', ()=>toggleADS(), {passive:true});

  // Code (7777 => Assist ON, others OFF)
  codeBtn.addEventListener('click', ()=>{
    const v = codeInput.value.trim();
    aimAssist = (v === '7777');
    updateUI();
    alert(aimAssist?'エイムアシストON（完全ロックオン）':'エイムアシストOFF');
  });

  // ========== Init ==========
  ensureTargets(5);
})();
</script>
</body>
</html>
